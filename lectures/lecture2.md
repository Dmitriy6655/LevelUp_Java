# Занятие 2. Типы данных. Переменные. Арифметичекие/логические операции.

0. [Введение](#input)
    1. [Представление данных в памяти](#input_1)
1. [Типы данных](#data_type)
    1. [Что такое тип данных?](#data_type_1)
    2. [Примитивные данные](#data_type_2)
    3. [Ссылочные типы данных](#data_type_3)
2. [Переменные](#variable)
    1. [Что такое переменные?](#variable_1)
    2. [Присваивание](#variable_2)
3. [Арифмитические операции](#arifmetic)
    1. [Бинарные операции](#arifmetic_1)
    2. [Унарные операции](#arifmetic_2)
    3. [Комбинированные операции](#arifmetic_3)
4. [Логические операции](#logical)
    1. [Операции сравнения](#logical_1)
    2. [Булевские операции](#logical_2)
    3. [Условная операция](#logical_3)
5. [Битовые операции](#bit)
6. [Приоритет операция](#logical_4)
7. [Привидение типов](#cast)

<a name="input"/>

## Введение

<a name="data_type"/>

## Типы данных

<a name="data_type_1"/>

### Что такое тип данных?

**Тип данных** — множество значений и операций на этих значениях (_IEEE Std 1320.2-1998_).

Тип определяет возможные значения и их смысл, операции, а также способы хранения значений типа. Неотъемлемой частью большинства языков программирования являются системы типов.

Существуют различные классификации типов и правил их назначения.

В Java выделяют два типа данных **примитивные** и **ссылочные**.
<a name="data_type_2"/>

### Примитивные данные

**Примитивный (встроенный, базовый) тип** — тип данных, предоставляемый языком программирования как базовая встроенная единица языка.

В зависимости от языка и его реализации, набор таких типов может сильно различаться. Он определяется требованиями к простоте языка и компилятора (интерпретатора), Обычно низкоуровненевые языки программирования предоставляют очень ограниченный набор встроенных типов, непосредственно реализующийся низкоуровневыми конструкциями. Напротив, языки высокого уровня предоставляют обычно большой набор встроенных типов, так как это позволяет повысить их производительность.

В **Java** есть **8 примитивных типов**, которые делят на 3 группы:

* Целые числа - **byte**, **short**, **char**, **int**, **long**
* Числа с плавающей точкой (иначе вещественные) - **float**, **double**
* Логический - **boolean**

#### Целочисленные типы

Целочисленные типы различаются между собой только диапазонами возможных значений, например, для хранения номера элемента в таблице Менделеева пока хватит переменной типа **byte**.

| Тип |	Размер (бит)	| Диапазон |
|:---:|:-------------:|:--------:|
| byte |	8 бит |	от 2^7 - 1 до -2^7 |
| short |	16 бит |	от 2^15 - 1 до - 2^15 |
| char |	16 бит |	беззнаковое целое число, представляющее собой символ UTF-16 (буквы и цифры) |
| int |	32 бит |	от 2^31 - 1 до - 2^31 |
| long |	64 бит |	от 2^63 -1  до  - 2^63|

Пример использования целочисленных типов:

    public class LevelUpIntegralTypes {
    	public static void main(String[] args) {
    		byte b = -17;
    		short s = 1123;
        char c = 'a'; // Cимволы тоже относят к целочисленным типам из-за особенностей представления в памяти и традиций.
    		int i = 64536;
    		long l = 2147483648L; // Постфикс l или L обозначает литералы типа long
    		System.out.println(b);
    		System.out.println(s);
        System.out.println(c);
    		System.out.println(i);
    		System.out.println(l);
    	}
    }

#### Типы с плавающей точкой
| Тип |	Размер (бит) |	Диапазон |
|:---:|:-------------:|:--------:|
| float |	32 бит |	от -1.4e-45f до 3.4e+38f |
| double |	64 бит |	от -4.9e-324 до 1.7e+308 |

Пример использования:

    public class LevelUpFloatingPointTypes {
    	public static void main(String[] args) {
    		double d = 4.12;
    		float pi = 3.14f; // При использовании типа float требуется указывать суффикс f или F
    		System.out.println(d);
        System.out.println(pi);
      }
    }

#### Логический тип

| Тип |	Размер (бит) |	Диапазон |
|:---:|:-------------:|:--------:|
| boolean |	8 (в массивах), 32 (не в массивах используется int) |	true (истина) или false (ложь) |

<a name="data_type_3"/>

### Ссылочные данные

**Ссылочные типы** - это все остальные типы: **классы**, **перечисления** и **интерфейсы**, например, объявленные в стандартной библиотеке Java, а также **массивы**.

#### Строки
**Строки** это объекты класса **String**, они очень распространены, поэтому в некоторых случаях обрабатываются отлично от всех остальных объектов. Строковые литералы записываются в двойных кавычках.

    public class LevelUpStrings {
    	public static void main(String[] args) {
    		String a = "Hello", b = "LevelUp";
    		System.out.println(a + " " + b); // Здесь + означает объединение (конкатенацию) строк
    	}
    }

#### ... Будет пополняться по мере проеведения курса ...

<a name="variable"/>

## Переменные

<a name="variable_1"/>

### Что такое переменные?


**Переменная** - это некоторый контейнер,  в котором может храниться значение для дальнейшего использования в программе.

Переменная предоставляется нам именем хранения, чтобы нашей программой можно было манипулировать. Каждая переменная в Java имеет конкретный тип, который определяет:
* размер и размещение её в памяти;
* диапазон значений, которые могут храниться в памяти;
* набор операций, которые могут быть применены к переменной.

Необходимо объявить все переменные, прежде чем их использовать. Ниже показана основная форма объявления:

**тип данных переменная [ = значение], [переменная [= значение], ...] ;**

Чтобы объявить более чем одну переменную указанного типа, можно использовать список с запятыми в качестве разделителей.

Ниже приведены примеры объявления переменной и инициализации в Java:

    int a, b, c;          // Объявление трех целых a, b, и c.
    int a = 10, b = 10;   // Пример инициализации.
    byte b = 22;          // Инициализация переменной b типа byte.
    double pi = 3.14159;  // Объявление и присвоение величины пи.
    char a = 'a';         // Переменной a типа char присваивается значение 'a'.

**Перед использованием переменной её обязательно необходимо проинициализировать(просвоить ей какое либо значение).**

<a name="variable_2"/>

### Присваивание

**Операция присваивания**

Присвоение переменной значения константы, другой переменной или выражения (переменных и/или констант, разделенных знаками операций), называется операцией присваивания и обозначается знаком "=", например:

    x = 3;
    y = x;
    z = x;

Операцию присваивания можно выполнить при объявлении переменной:

    int a = 10;

Либо после объявления переменной но перед её использованием:

    int a;
    ...
    a = 10;
    ...
    b = a + 4;

В Java допустимо многократное использование операции присваивания в одном выражении, например:

    x1 = x2 = x3 = 0;

Эта операция выполняется справа налево, т.е. сначала переменной x3 присваивается значение 0, затем переменной x2 присваивается значение переменной x3 (0), и, наконец, переменной x1 присваивается значение переменной x2 (0).

<a name="arifmetic"/>

## Арифмитические операции

Большинство операций над примитивными типами выполняется не с помощью методов, а с помощью специальных символов, называемых **знаком операции**.

Знаки операций, аргументами которых являются числа, разделяются на две категории: **унарные** знаки операций с одним аргументом и **бинарные** с двумя аргументами.

<a name="arifmetic_1"/>

### Бинарные операции

В Java определены следующие арифметические бинарные операции:
* сложение "+";
* вычитание "-";
* умножение "*";
* деление "/";
* вычисление остатка от деления "%"

Примеры бинарных арифметических операций:

    int x = 7, x1, x2, x3, x4, x5;
    x1 = x + 10; // x1 = 17
    x2 = x – 8; // x2 = -1
    x3 = x2 * x; // x3 = -7
    x4 = x/4; // x4 = 1 (при делении целых чисел дробная часть отбрасывается)
    x5 = x%4 // x5 = 3 (остаток от деления 7 на 4)

<a name="arifmetic_2"/>

### Унарные операции

В Java определены следующие унарные операции:
* унарный минус "-" – меняет знак числа или выражения на противоположный;
* унарный плюс "+" – не выполняет никаких действий над числом или выражением;
* побитовое дополнение "~" (только для целых) – инвертирует все биты поля числа (меняет 0 на 1 и 1 на 0);
* инкремент "++" (только для целых) – увеличивает значение переменной на 1;
* декремент "--" (только для целых) – уменьшает значение переменной на 1.

Примеры унарных операций "+" и "-":

    int i = 3, j, k;
    j= -i; // j = -3
    k = +i; // k = 3

Пример операции побитового дополнения:

    int a = 15;
    int b;
    b = ~a; // b = -16

Числа a и b являются числами типа int, т.е. представляются внутри компьютера как двоичные целые числа со знаком длиной 32 бита, поэтому двоичное представление чисел a и b будет выглядеть следующим образом:

    a = 00000000 00000000 00000000 00001111
    b = 11111111 11111111 11111111 11110000

Как видно из этого представления, все нулевые биты в числе a изменены на единичные биты в числе b, а единичные биты в a изменены на нулевые биты. Десятичным представлением числа b будет –16.

Знаки операции инкремента и декремента могут размещаться как до, так и после переменной. Эти варианты называются соответственно префиксной и постфиксной записью этих операции. Знак операции в префиксной записи возвращает значение своего операнда после вычисления выражения. При постфиксной записи знак операции сначала воз­вращает значение своего операнда и только после этого вычисляет инкремент или декремент, например:

    int x = 1, y, z;
    y = ++x;
    z = x++;

Переменной y будет присвоено значение 2, поскольку сначала значение x будет увеличено на 1, а затем результат будет присвоен переменной y. Переменной z будет присвоено значение 1, поскольку сначала переменной z будет присвоено значение, а затем значение x будет увеличено на 1. В обоих случаях новое значение переменной x будет равно 2.

Следует отметить, что в Java, в отличие от языка C, операции декремента и инкремента могут применяться и к вещественным переменным (типа float и double).

Бинарные знаки операций подразделяются на операции с числовым результатом и операции сравнения, результатом которых является булевское значение.

<a name="arifmetic_3"/>

### Комбинированные операции

Комбинированные операции
В Java для бинарных арифметических операций можно использовать комбинированные (составные) знаки операций:

**идентификатор операция = выражение**

Это эквивалентно следующей операции:

**идентификатор = идентификатор операция выражение**

Примеры:
* Выражение x += b означает x = x + b.
* Выражение x -= b означает x = x - b.
* Выражение x *= b означает x = x * b.
* Выражение x /= b означает x = x / b.
* Выражение x %= b означает x = x % b.

<a name="logical"/>

## Логические операции

Логическими операциями можно назвать операции, результатом выполнения которых является логичекое значение(true/false).

<a name="logical_1"/>

### Операции сравнения

В Java определены следующие операции сравнения:

* "==" (равно)
*  "!=" (не равно),
* ">" (больше)
*  ">=" (больше или равно),
* "<" (меньше)
*  "<=" (меньше или равно)

Эти операции имеют два операнда и возвращают булевское значение, соответствующее результату сравнения (false или true).

Примеры операций сравнения:

    boolean isEqual, isNonEqual, isGreater, isGreaterOrEqual, isLess, isLessOrEqual;
    int x1 = 5, x2 = 5, x3 = 3, x4 = 7;
    isEqual = x1 == x2;           // isEqual = true
    isNonEqual = x1 != x2;        // isNonEqual = false
    isGreater = x1 > x3;          // isGreater = true
    isGreaterOrEqual = x2 >= x3;  // isGreaterOrEqual = true
    isLess = x3 < x1;             // isLess = true
    isLessOrEqual = x1 <= x3;     // isLessOrEqual = false

<a name="logical_2"/>

### Булевские операции

Булевские операции выполняются над булевскими переменными и их результатом также является значение типа boolean. В Java определены следующие булевские операции:

отрицание "!" – замена false на true, или наоборот;
операция И "&" – результат равен true, только, если оба операнда равны true, иначе результат – false;
операция ИЛИ "|" – результат равен true, только, если хотя бы один из операндов равен true, иначе результат – false.
операция исключающее ИЛИ "^" – результат равен true, только, если операнды не равны друг другу, иначе результат – false.

Операции "&", "|" и "^" можно, также как и соответствующие побитовые операции использовать в составных операциях присваивания: "&=", "|=" и "^="

Кроме того, к булевским операндам применимы операции "==" (равно) и "!=" (не равно).

Как видно из определения операций ИЛИ и И, операция ИЛИ приводит к результату true, когда первый операнд равен true, незави­симо от значения второго операнда, а операция И приводит к результату false, когда первый операнд равен false, независимо от значения второго операнда.

В Java определены еще две булевские операции: вторые версии булевских операций И и ИЛИ, известные как укороченные (short-circuit) логические операции: укороченное И "&&" и укороченное ИЛИ "||". При использовании этих операций второй операнд вообще не будет вычисляться, что полезно в тех случаях, когда правильное функционирование правого операнда зависит от того, имеет ли левый операнд значение true или false.

Примеры булевских операций:

    boolean isInRange, isValid, isNotValid,
    isEqual, isNotEqual;
    int x = 8;
    isInRange = x > 0 && x < 5; // isInRange = false
    isValid = x > 0 || x > 5; // isValid = true
    isNotValid = !isValid; // isNotValid = false
    isEqual = isInRange == isValid; // isEqual = false
    isNotEqual = isInRange != isValid // isNotEqual = true

<a name="logical_3"/>

### Условная операция

Условная операция.
Условная операция записывается в форме.

 **выражение-1?выражение-2:выражение-3.**

При этом сначала вычисляется выражение выражение-1, которое должно дать булевское значение, а затем, если выражение-1 имеет значение true, вычисляется и возвращается выражение-2 как результат выполнения операции, либо (если выражение-1 имеет значение false), вычисляется и, как результат выполнения операции, возвращается выражение-3.

Пример условной операции:

    x=n>1?0:1;

Переменной x будет присвоено значение 0, если n>1 (выражение n>1 имеет значение true) или 1, если n≤1 (выражение n>1 имеет значение false).


<a name="bit"/>

## Битовые операции

Побитовые операции рассматривают исходные числовые значения как поля битов и выполняют над ними следующие действия:

* установка бита в i-ой позиции поля результата в 1, если оба бита в i-ых позициях операндов равны 1, или в 0 в противном случае – побитовое И ("&");
* установка бита в i-ой позиции поля результата в 1, если хотя бы один бит в i-ых позициях операндов равен 1, или в 0 в противном случае – побитовое ИЛИ ("|");
* установка бита в i-ой позиции поля результата в 1, если биты в i-ых позициях операндов не равны друг другу, или в 0 в противном случае – побитовое исключающее ИЛИ ("^");
* сдвиг влево битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом не меняется) – побитовый сдвиг влево с учетом знака "<<";
* сдвиг вправо битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом не меняется) – побитовый сдвиг вправо с учетом знака ">>";
* сдвиг вправо битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом также сдвигается) – побитовый сдвиг вправо без учета знака ">>>".

Примеры побитовых операций:

Побитовое И

    int x = 112;
    // x: 00000000 00000000 00000000 01110000
    int y = 94;
    // y: 00000000 00000000 00000000 01011110
    int z;
    z = x & y;
    // z=80: 00000000 00000000 00000000 01010000

Побитовое ИЛИ

    int x = 112;
    // x: 00000000 00000000 00000000 01110000
    int y = 94;
    // y: 00000000 00000000 00000000 01011110
    int z;
    z =x | y;
    // z = 126: 00000000 00000000 00000000 01111110

Побитовое исключающее ИЛИ

    int x = 112;
    // x: 00000000 00000000 00000000 01110000
    int y = 94;
    // y: 00000000 00000000 00000000 01011110
    int z;
    z =x ^ y;
    // z = 46: 00000000 00000000 00000000 00101110

Сдвиг влево с учетом знака

    int x = 31, z;
    // x: 00000000 00000000 00000000 00011111
    z = x << 2;
    // z = 124: 00000000 00000000 00000000 01111100

Сдвиг вправо с учетом знака

    int x = -17, z;
    // x: 11111111 11111111 11111111 11101111
    z = x >> 2;
    // z = -5: 11111111 11111111 11111111 11111011

Сдвиг вправо без учета знака

    int x = -17, z;
    // x: 11111111 11111111 11111111 11101111
    z = x >>> 2;
    // z = 1073741819
    // z: 00111111 11111111 11111111 11111011


<a name="logical_4"/>

### Приоритет операция

Операции в выражениях выполняются слева направо, однако, в соответствии со своим приоритетом. Так операции умножения в выражении

    y = x +z * 5;

будет выполнена раньше, чем операция сложения, поскольку приоритет операции умножения выше, чем приоритет операции сложения.

Приоритеты операций():

| № | | | |
|:-:|:-:|:-:|:-:|
| 1 | ( ) |  [] |  • |
| 2 | ~ | ! |
| 3 | * | / | % |
| 4 | + | - |
| 5 | >>  | >>>  | << |
| 6 | > |  >= | < | <= |
| 7 | == | != |
| 8 | & |
| 9 | ^ |
| 10 |  \| |
| 11 | && |
| 12 | \|\| |
| 13 | ? : |
| 14 | = |

Где 1 - самая операция с самым высоким приоритетом.

Круглые скобки повышают старшинство операций, которые находятся внутри них. Так, если в приведенное выше выражение вставить скобки:

    y = (x +z)*5;

то сначала будет выполнена операция сложения, а затем операция умножения.

Иногда скобки используют просто для того, чтобы сделать выражение более читаемым, например:

    (x > 1) && (x <= 5).


<a name="cast"/>

## Привидение типов

При рассмотрении типов данных указывалось, какие значения может иметь тот или иной тип и сколько байт памяти он может занимать. И мы можем написать, например, так:

    byte x = 5;
    byte y = x;

Но важно понимать, что это запись не эквивалентна следующей (хотя результат будет тот же):

    byte x = 5;
    int y = x;

В обоих случаях создается переменная типа byte, которая затем приравнивается другой переменной. Однако если в первом случае это простое приравнивание, а переменная y просто получает значение переменной x, то во втором примере происходит преобразование типов: данные типа byte преобразуются к типу int. Данный тип преобразований называется расширяющим, так как значение типа byte расширяет свой размер до размера типа int. Расширяющие преобразования проходят автоматически и обычно с этим никаких проблем не возникает.

Подобным образом происходит преобразование от типа float к типу double или от типа int к типу long.

Кроме расширяющих преобразований есть еще и сужающие. Сужающие преобразования позволяют привести данные к типу с меньшей разрядностью, например, от типа int, который занимает 4 байта в памяти, к типу byte, который занимает только 1 байт в памяти:

    int a = 4;
    byte b = a;     // ! Error

Несмотря на то, что значение переменной a - число 4 укладывается в диапазон типа byte, мы все равно получим ошибку. И чтобы безошибочно провести преобразование из одного типа к другому, нам надо применить операцию приведения типов. Суть этой операции состоит в том, что в скобках указывается тип, к которому надо привести данное значение:

    int a = 4;
    byte b = (byte) a;

Потеря данных при преобразовании
В предыдущей ситуации число 4 вполне укладывалось в диапазон значений типа byte. Но что будет в следующем случае:

    int a = 200;
    byte b = (byte) a;

Результатом будет число -56. В данном случае число 200 вне диапазона для типа byte (от -128 до 127), поэтому произойдет усечение значения.

#### Усечение рациональных чисел до целых
При преобразовании значений с плавающей точкой к целочисленным значениям, происходит усечение дробной части:

    double a = 56.9898;
    int b = (int)a;

#### Преобразования при операциях
Нередки ситуации, когда приходится применять различные операции, например, сложение и произведение, над значениями разных типов. Здесь также действуют некоторые правила:

* если один из операндов операции относится к типу double, то и второй операнд преобразуется к типу double

* если предыдущее условие не соблюдено, а один из операндов операции относится к типу float, то и второй операнд преобразуется к типу float

* если предыдущие условия не соблюдены, один из операндов операции относится к типу long, то и второй операнд преобразуется к типу long

* иначе все операнды операции преобразуются к типу int

Примеры преобразований:

    int a = 3;
    double b = 4.6;
    double c = a+b;

Так как в операции участвует значение типа double, то и другое значение приводится к типу double и сумма двух значений a+b будет представлять тип double.

Другой пример:

    byte a = 3;
    short b = 4;
    byte c = (byte)(a+b);

Две переменных типа byte и short (не double, float или long), поэтому при сложении они преобразуются к типу int, и их сумма a+b представляет значение типа int. Поэтому если затем мы присваиваем эту сумму переменной типа byte, то нам опять надо сделать преобразование типов к byte.

Если в операциях участвуют данные типа char, то они преобразуются в int:

    int d = 'a' + 5;
    System.out.println(d);  // 102

Стоит отметить, что несмотря на то, что преобразования из int -> float, long -> float и long -> double произволятся без ошибок, но при преобразовании мы можем столкнутьс с потерей информации.
