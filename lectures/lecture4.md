# Занятие 4. Операторы ветвления. Циклы.

1. [Введение](#if)
2. [Оператор if](#if1)
3. [Оператор else](#if2)
4. [Оператор switch](#if3)
5. [Ключевое слово break](#if4)
6. [Ключевое слово default](#if5)
7. [Циклы](#loop)
    1. [for](#for)
    2. [while](#while)
    3. [do while](#do_while)
8. [Операторы перехода](#loop1)
9. [Оператор break](#loop2)
10. [Оператор continue](#loop3)

<a name="if"/>

## Введение

**Ветвление (условная инструкция)** - это конструкция языка программирования, обеспечивающая выполнение определённой команды или набора команд только при условии истинности некоторого логического выражения, либо выполнение одной из нескольких команд (наборов команд) в зависимости от значения некоторого выражения.

**Цикл** — это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций.

В основе ветвления и отдельных циклов лежат логические операторы сравнения, определяющие необходимость выполнение следующих строк кода или перехода к другим. Операторы сравнения мы рассматривали ранее в [лекции 2](.//lectures/lecture2.md).


<a name="if1"/>

## Оператор if

Этот оператор проверяет, равно ли выражение в скобках true. Если да, то действие выполняется. Если нет, то идёт следующая после блока команда. Пример:

    class Test {
        public static void main(String[] args){
            if(true) {
                System.out.println("Тест прошёл успешно.");
            }
        }
    }

Вывод в консоли:

    Тест прошёл успешно.

Как видите, этот оператор сработал успешно, так как в выражение в скобках равно true.

## Оператор else
Действия, написанные в операторе else , будут выполнены, только если значение if равно false. Пример:

    class AnotherTest {
        public static void main(String[] args){
            if(false) {
                System.out.println("Тест прошёл не очень успешно.");
            } else {
                System.out.println("Тест прошёл успешно.");
            }
        }
    }
Вывод в консоли:

    Тест прошёл успешно.

## Оператор switch

Данный способ сравнивает, то что дано в switch ( в примере снизу это число типа int с переменной i ) и то что написано после ключевого слова case. Таким образом switch сравнивает i с возможными значениями. Пример:

    class SwitchTest {
        public static void main(String[] args) {
            int i = 2;
            switch(i) {
                case 1:
                    System.out.println("Тест работает.");
                    break;
                case 2:
                    System.out.println("Тест добрый.");
                    break;
                case 3:
                    System.out.println("Тест поможет вам.");
                    break;
            }
        }
    }

Вот код без использования switch , который делает то же самое:

    class NoSwitchTest {
        public static void main(String[] args) {
            int i = 2;
            if(i == 1) { // аналог "case 1"
                System.out.println("Тест работает");
            } else if(i == 2) { // аналог "case 2"
                System.out.println("Тест добрый");
            } else if(i == 3) { // аналог "case 3"
                System.out.println("Тест поможет вам");
            }
        }
    }

Вывод в консоли будет:

    Тест добрый.

## Ключевое слово break

Теперь подробнее про ключевое слово break . По умолчанию после того как нужный код из case выполнен, оператор ( если нет этого слова ) перескакивает на следующий case без проверки, таким образом, если бы мы не ставили слово break

вывод в консоли был бы:

    Тест добрый

    Тест поможет вам

Ключевое слово default

Предположим case'ов может быть много, а число не подходит ни к одному. Для таких ситуаций и нужен "default". Он выполняется в случае, если ни один из case'ов не сработал. Обратите внимание, что break в секции default необязателен. Пример :

    class DefaultTest {
        public static void main(String[] args) {
            int i = 152;
            switch(i) {
                case 1:
                    System.out.println("Тест работает");
                    break;
                case 2:
                    System.out.println("Тест добрый");
                    break;
                case 3:
                    System.out.println("Тест поможет вам");
                    break;
                default:
                    System.out.println("Тест интересный");
            }
        }
    }
Вывод на консоль :

    Тест интересный

Он default как и все case тоже выполняется, если нет ключевого слова break . Пример:

    class DefaultAndBreakTest {
        public static void main(String[] args) {
            int i = 1;
            switch(i) {
                case 1:
                    System.out.println("Тест работает");
                case 2:
                    System.out.println("Тест добрый");
                case 3:
                    System.out.println("Тест поможет вам");
                default:
                    System.out.println("Тест интересный");
            }
        }
    }
Вывод в консоли :

    Тест работает

    Тест добрый

    Тест поможет вам

    Тест интересный

<a name="loop"/>

## Циклы

**Цикл** — это блок команд, который выполняется снова и снова, пока соблюдается определённое условие. Повторяемый фрагмент кода называют **«телом цикла»**. Одно  выполнение тела цикла называют **итерацией**.

В Java можно работать с циклами нескольких типов - для этого есть следующие операторы:

* **while** – цикл с предусловием – сначала проверяем условие, затем выполняем тело цикла;

* **do… while** – цикл с постусловием – сначала выполняем один раз тело цикла, затем проверяем условие и, если оно соблюдается, продолжаем;

* **for** – цикл со счётчиком – выполняется и при каждой итерации обновляет счётчик, пока условие в объявлении цикла соблюдается (т.е. проверка условия возвращает true);

* **сокращенный for** (в других языках известен как foreach) – перебирает массив от первого элемента до последнего и на каждой итерации выполняет тело цикла.

<a name="whie"/>

## Цикл while
Оператор цикла while есть практически во всех языках программирования. Он повторяет оператор или блок операторов до тех пор, пока значение его управляющего выражения истинно.

Форма цикла while следующая:

    while(условие) {
        // тело цикла
    }

Здесь условие должно быть любым булевым выражением. Тело цикла будет выполняться до тех пор, пока условное выражение истинно. Когда условие становится ложным, управление передаётся строке кода, которая идёт после цикла. Если в цикле используется только один оператор, то фигурные скобки можно опустить (но лучше так не делать).

Логическое выражение вычисляется перед началом цикла, а затем каждый раз перед выполнением очередного повторения оператора.

Напишем пример с использованием цикла while, который выполняет обратный отсчёт от 10 до 0:

    int counter = 10;
    while (counter > 0) {
        mInfoTextView.append("Осталось " + counter + " сек.\n");
    	counter--;
    }
Программа выведет десять строк:

    Осталось 10 сек.
    Осталось 9 сек.
    Осталось 8 сек.
    Осталось 7 сек.
    Осталось 6 сек.
    Осталось 5 сек.
    Осталось 4 сек.
    Осталось 3 сек.
    Осталось 2 сек.
    Осталось 1 сек.

Если нужно увеличивать от единицы до 10, то код будет следующим.

    int counter = 1;
    while(counter < 11){
        System.out.println(counter);
        counter++;
    }

Поскольку цикл while вычисляет своё условное выражение в начале цикла, то тело цикла не будет выполняться, если условие с самого начала было ложным.

    boolean isHungry; // голоден ли кот
    isHungry = true; // где вы видали сытого кота?
    while(!isHungry) {
        mInfoTextView.setText("Случилось чудо - кот не голоден");
    }

Вы никогда не увидите сообщение, так как сытый кот - это из области фантастики.

Обратный пример - бесконечный цикл. Создадим условие, которое всегда имеет значение true.

    boolean isHungry; // голоден ли кот
    isHungry = true;
    while(isHungry) {
        System.out.println("Кот голодный...");
    }
В логах будет постоянно выводиться надпись "Кот голодный...".

<a name="for"/>

## Цикл for

Цикл for — обладает структурой управления повторений, что позволяет эффективно написать цикл, который должен выполниться определенное количество раз. Цикл for полезен, когда Вы знаете, сколько раз задача должна быть повторена.


    for(инициализация; логическое выражение; обновление) {
       //Операторы
    }
Процесс управления в цикле:

Стадия инициализации выполняется первой, и только один раз. Этот шаг позволяет объявлять и инициализировать любые переменные для управления циклом, и он заканчивается точкой с запятой(;).
Далее логическое выражение. Если истинно, то тело цикла выполняется, если оно ложно, тело цикла не будет выполнено и контроль переходит к следующему оператору мимо цикла.
После того как тело из цикла for запускается на выполнение, контроль переходит обратно к оператору обновления. Он позволяет обновлять какие-либо переменные для управления циклом, и записывается без точки с запятой в конце.
Логическое выражение теперь оценивается снова. Если истинно, то цикл выполняется и процесс повторяется. Если ложно, то цикл for завершается.
Описание процесса


    for(int x = 10; x < 15; x = x+1) {
       System.out.print("Значение x: " + x );
       System.out.print("\n");
    }
Будет получен следующий результат:

    Значение х: 10
    Значение х: 11
    Значение х: 12
    Значение х: 13
    Значение х: 14

<a name="dowhile"/>

## Цикл do-while

Конструкция цикла:

    do
        // команда (тело цикла)
    while(условие-логическое выражение)

Отличие цикла do-while от цикла while состоит в том, что цикл do-while выполняется по крайней мере один раз, даже если условие изначально ложно. В цикле while такое не произойдёт, так как тело цикла не отработается. Цикл do-while используется реже, чем while.

Бывают ситуации, когда проверку прерывания цикла желательно выполнять в конце цикла, а не в его начале. И данный цикл позволяет это сделать. При каждом повторении цикла do-while программа сначала выполняет тело цикла, а затем вычисляет условное выражение. Если это выражение истинно, то цикл повторяется. В противном случае выполнение цикла прерывается. Как и в других циклах Java, условие должно иметь булево значение.

    int counter = 10;
    do {
        mInfoTextView.append("Осталось " + counter + " сек.\n");
    	counter--;
    } while (counter > 0);
Если теперь изменить условие counter < 0, то цикл отработает один раз и выведет одну строку:

    Осталось 10 сек.
Пример можно переписать следующим образом:

    int counter = 10;
    do {
        mInfoTextView.append("Осталось " + counter + " сек.\n");
    } while (--counter > 0);

Мы объединили декремент счётчика и сравнение с нулём в одном выражении. Программа работает следующим образом. Вначале она выполняет операцию уменьшения на единицу и возвращая новое значение счётчика. Затем сравнивается значение с нулём. Если оно больше нуля, выполнение цикла продолжается. В противном случае цикл прерывается.

<a name="loop1"/>

## Операторы перехода

Как выйти из цикла Java

Для выхода из цикла есть ключевые слова **break** — «прервать», **continue** — «возобновить» и **return** — «вернуться».

<a name="loop2"/>

## Оператор break

Оператор **break** завершает последовательность операторов в операторе switch, позволяет выйти из цикла и в качестве оператора безусловного перехода.

Рассмотрим пример выхода из цикла. Используя оператор **break**, можно вызвать немедленное завершение цикла, пропуская условное выражение и другой код в теле цикла. Когда приложение встречает оператор break внутри цикла, оно прекращает выполнение цикла и передаёт управление оператору, следующему за циклом.

    for(int i = 0; i < 100; i++) {
        if(i == 5) break; // выходим из цикла, если i равно 5
    	mInfoTextView.append("i: " + i + "\n");
    }
    mInfoTextView.append("Цикл завершён");

Получим следующий результат:

    i: 0
    i: 1
    i: 2
    i: 3
    i: 4
    Цикл завершён


Код можно переписать с использованием цикла while:

    int i = 0;

    while(i < 100) {
        if(i == 5) break; // выходим из цикла, если i равно 5
    	mInfoTextView.append("i: " + i + "\n");
    	i++;
    }
    mInfoTextView.append("Цикл завершён");
Результат будет такой же.

**При использовании вложенных циклов оператор break осуществляет выход только из самого внутреннего цикла**, не оказывая влияния на внешний цикл. Создадим пример с использованием вложенных циклов:


    for (int i = 1; i < 4; i++) {
    	mInfoTextView.append("Проход " + i + ": ");
    	for (int j = 0; j < 100; j++) {
    		if (j == 5)
    			break; // выходим из цикла, если j равно 5
    		mInfoTextView.append(j + " ");
    	}
    	mInfoTextView.append("\n");
    }
    mInfoTextView.append("Циклы завершёны");
    Получим следующий результат:

    Проход 1: 0 1 2 3 4
    Проход 2: 0 1 2 3 4
    Проход 3: 0 1 2 3 4
    Циклы завершёны

В примере оператор break прервал выполнение второго цикла, но первый цикл продолжал работать.

В цикле можно использовать несколько операторов break, но увлекаться не стоит. Лучше переделайте код.

<a name="loop3"/>

## Оператор continue
Иногда требуется, чтобы повторение цикла начиналось с более раннего оператора его тела. В циклах while и do-while оператор continue вызывает передачу управления непосредственно управляющему условному выражению цикла. В цикле for управление передаётся вначале итерационной части цикла for, а потом условному выражению. При этом во всех циклах промежуточный код пропускается.

В следующем примере выводим два числа в каждой строке:

    for (int i = 0; i < 10; i++) {
    	mInfoTextView.append(i + " ");
    	if (i % 2 == 0)
    		continue;
    	mInfoTextView.append("\n");
    }

В этом коде оператор % служит для проверки чётности значения переменной i. Если значение чётное, выполнение цикла продолжится дальше, а если нечётное, то произойдёт переход на новую строку. В результате мы получим следующий текст:

    0 1
    2 3
    4 5
    6 7
    8 9

<a name="loop4"/>

## Оператор return
Оператор **return** используют для выполнения явного выхода из метода. Оператор можно использовать в любом месте метода для возврата управления тому объекту, который вызвал данный метод. Таким образом, return прекращает выполнение метода, в котором он находится.
