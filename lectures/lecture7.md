# Паттерны проектирования

Паттерны (или шаблоны) проектирования описывают типичные способы решения часто встречающихся проблем при проектировании программ.

## Зачем знать паттерны?
Вы можете вполне успешно работать, не зная ни одного паттерна. Более того, вы могли уже не раз реализовать какой-то из паттернов, даже не подозревая об этом.

Но осознанное владение инструментом как раз и отличает профессионала от любителя. Вы можете забить гвоздь молотком, а можете и дрелью, если сильно постараетесь. Но профессионал знает, что главная фишка дрели совсем не в этом. Итак, зачем же знать паттерны?

Проверенные решения. Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда. До некоторых решений вы смогли бы додуматься и сами, но многие могут быть для вас открытием.

Стандартизация кода. Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так как все скрытые проблемы в них уже давно найдены.

Общий программистский словарь. Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, какой крутой дизайн вы придумали и какие классы для этого нужны.

## Классификация паттернов
Паттерны отличаются по уровню сложности, детализации и охвата проектируемой системы. Проводя аналогию со строительством, вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой автомобильной развязкой с подземными переходами.

Самые низкоуровневые и простые паттерны — **идиомы**. Они не универсальны, поскольку применимы только в рамках одного языка программирования.

Самые универсальные — **архитектурные паттерны**, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.

Кроме того, паттерны отличаются и предназначением. В этой книге будут рассмотрены три основные группы паттернов:

**Порождающие паттерны** беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

**Структурные паттерны** показывают различные способы построения связей между объектами.

**Поведенческие паттерны** заботятся об эффективной коммуникации между объектами.

## Порождающие паттерны

**Абстрактная фабрика**(Abstract factory)

Класс, который представляет собой интерфейс для создания компонентов системы.

**Строитель**(Builder)

Класс, который представляет собой интерфейс для создания сложного объекта.

**Фабричный метод**(Factory method)

Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать.

**Прототип**(Prototype)

Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.

**Одиночка**(Singleton)

Класс, который может иметь только один экземпляр.

## Структурные шаблоны

**Адаптер**(Adapter / Wrapper)

Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.

**Мост**(Bridge)

Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.

**Обёртка**(Decorator)

Класс, расширяющий функциональность другого класса без использования наследования.

**Фасад**(Facade)

Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.

**Заместитель**(Proxy)

Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.

## Поведенческие шаблоны

**Команда**(Command)

Представляет действие. Объект команды заключает в себе само действие и его параметры.

**Интерпретатор**(Interpreter)

Решает часто встречающуюся, но подверженную изменениям, задачу.

**Итератор**(Iterator)

Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из объектов, входящих в состав агрегации.

**Посредник**(Mediator)

Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.

**Наблюдатель или Издатель-подписчик**(Observer)

]Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.
